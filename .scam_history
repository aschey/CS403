(exp 2 4)
(exp 2)
(expt 2 4)
1.000000e-06
(abs 2)
(< 0 1.000000e-06)
(< (abs (/ 2 2)) 1.000000e-06)
(> (abs (/ 2 2)) 1.000000e-06)
(abs (/ 2 2))
(define (test $la) println ($la))
test
(= 1 1 1 1)
(= 1 1 1 2)
(min 3 4)
import
load
(load)
(import)
(open "assign1.scm")
(include "assign1.scm")
load
import
(include assign1.scm)
(include "assign1.scm")
(run1)
(min5 0 0 0 0 0)
(min5 -2 3 4 5 3)
(min5 -2 3 4 5 3)
(min5 10 9 8 7 5)
(min5 1 2 2 2 2)
(min5 2 2 2 2 1)
(min5 2 1 2 2 2)
(min5 2 2 1 2 2)
(min5 2 2 2 1 2)
(cym 100)
(cym 0)
(cym 50)
(run9)
(load "assign1.scm")
(include "assign1.scm")
(mystery 9 1 (lambda n) (+ (* 4 n) 1))
(lambda n)
1
(include "assign1.scm")
(mystery 9 1 (lambda n) (+ (* 4 n) 1))
(load "assign1.scm")
(include "assign1.scm")
(mystery 9 1 (lambda (n) (+ (* 4 n) 1)) (lambda (n) 1))
(mystery 100 1 (lambda (n) (+ (* 4 n) 1)) (lambda (n) 1))
(mystery 1000 1 (lambda (n) (+ (* 4 n) 1)) (lambda (n) 1))
(mystery 1000 1 (lambda n 1) (lambda (n) (+ (* 4 n) 1)))
(include "assign1")
(run1)
(include "assign1.scm")
(run1)
(cym 0)
(cym 25)
(cym 50)
(cym 75)
(cym 100)
(cym 99)
cym
(1)
(cym 1)
(run1)
(include "assign1.scm")
(include "assign1.scm")
(include "assign1.scm")
(egypt/ 3223 2342)
(egypt/ 4684 2342)
(egypt/ 4683 2342)
(ramanujan 4)
(ramanujan 3)
(ramanujan 0)
(define f a b c d=5)
(define a "a")
(= a "a")
(+ 2 +)
(. +)
(. + +)
(dot 2)
(. 2)
(. 2 2)
.
2.2000000000
(environment)
(eq? 2)
(eq? +)
(eq? #f)
(eval 0)
(true? 0)
(true? 1)
(true? +)
(. 2 (1 2))
(dot 2 (1 2))
(2 1)
(number? 3)
(? a)
(ppTable this)
e
e
(= e 2)
(> +)
(> 2)
(> -3)
(> 2 +)
(> + 2)
(not +)
(not 1)
(define a (list 1 2 3 4))
(cadr a)
(caadr a)
(caar a)
a
(cdr a)
(cddr a)
(define (gcd m n) (if (= n 0) m (gcd n (% m n))))
(gcd 412 63)
63
%
378
63
*
6
(% 412 63)
(% 63 34)
(% 34 29)
(% 29 5)
(% 5 4)
(4 % 1)
(% 4 1)
(% 123 31)
(31 % 30)
(% 31 30)
(% 30 1)
(lambda (x) ((lambda (x y) (- x y)) 10 6))
(define (a b c d e f) (define (iter x y) (if (= y c) x (iter (f x y) (e y)))) (iter d b))
(a 1 5 0 + (lambda (x) (+ x 1)))
(a 1 5 0 (lambda (x) (+ x 1)) +)
(+ 1 2 3 4 5)
(a 1 5 5 (lambda (x) (+ x 1)) +)
(length (list 1 2))
(car (list 1 2))
(append (array 2 3) 2)
(append (array 2 3) (list 2))
(append (array 2 3) (array 2))
(define q (list 1 2 3 4))
(caar q)
q
(define q (list 1 2 3 4))
q
(println "sdfs")
(define a quote (define (nsq a) (define x (+ a 1)) (* x x)))
(define a (define (nsq a) (define x (+ a 1)) (* x x)))
(define a (quote (define (nsq a) (define x (+ a 1)) (* x x))))
a
(car (cddr a))
(cddr a)
a
(define b (cddr a))
a
b
(car b)
b
(car (car b))
(cdr b)
a
b
(car b)
(define current (car b))
current
(define varName (cadr current))
(caddr current)
current
a
b
current
body
current
b
(cdr b)
b
(cdr b)
:q
(put (quote s))
apply
(apply (lambda (x) (+ x 1)) (list 1 2 3))
(apply (lambda (x) (+ x 1)) 1)
(apply (lambda (x) (quote a)))
1
(apply (lambda (x) (quote a)) 1)
(apply (lambda (x) (car x)) (list 2 3))
(apply (lambda (x y) (car x)) (list 2 3))
(apply (lambda (x y) y) (list 2 3))
(define (cons a b) (lambda (f) ((f a) b)))
cons
(cons 1 (list 3 4))
(define c (lambda (x) (lambda (y) a)))
c
(c (cons 1 (list 2 3)))
((c (cons 1 (list 2 3))))
((c (cons 1 (list 2 3))) 0)
(define c (lambda (x) (lambda (y) y)))
(c (cons 1 (list 2 3)))
((c (cons 1 (list 2 3))) 0)
((c (cons 1 (list 2 3))) 4)
(c (list 2 3 4))
(c (list 2 3 4) 0)
(c (list 2 3 4) 0 1)
(c (list 2 3 4))
((c (list 2 3 4)) 0)
((c (list 2 3 4)) 1)
(define (kahns a b) (lambda (f) ((f a) b)))
(kahns 2 (list 3 4))
(define cahr c)
(c (lambda (y) (lambda (x) y)))
(define (cahr c) (c (lambda (y) (lambda (x) y))))
(define (kahns a b) (lambda (f) ((f a) b)))
(cahr (khans 2 (list 3 4)))
(cahr (kahns 2 (list 3 4)))
(define four (lambda (f) (lambda (x) (f (f (f (f x)))))))
(four)
(define (add a) (lambda (b) (lambda (f) (lambda (x) ((a f) ((b f) x))))))
(define one (lambda (f) (lambda (x) (f x))))
(add a)
((add one) one)
one
(define test x)
x
(define one (lambda (f) (lambda (x) (f x))))
(define (add a) (lambda (b) (lambda (f) (lambda (x) ((a f) ((b f) x))))))
(define (test x) x)
(define (test x) x)
(define (add a) (lambda (b) (lambda (f) (lambda (x) ((a f) ((b f) x))))))
(define one (lambda (f) (lambda (x) (f x))))
(one test 1)
((one test) 1)
(define two (lambda (f) (lambda (x) (f (f x)))))
((two test) 1)
(define (test x) (+ x 1))
((two test) 1)
((one test) 1)
((add one) one)
((((add one) one) test) 1)
((one add) one)
((((one add) one) test) 1)
(one (add one))
((one (add one)) 1)
(one (add one))
((one (add one)) 1)
(((one (add one)) 1) test)
((((one (add one)) 1) test) 1)
(define (mul a b) (lambda (f) (lambda (x) ((((a add) b) f) x))))
(mul one one)
((mul one one) test)
(((mul one one) test) 1)
((((mul one one) test) 1) 1)
((((mul one one) test) 1) test)
((((mul one one) test) test) test)
((((mul one one) test) test) 1)
(define zero (lambda (f) (lambda (x) x)))
(define (mul2 a b) (lambda (f) (lambda (x) ((((a (add b)) zero) f) x))))
(mul2 one one)
((mul2 one one) test)
(((mul2 one one) test) 1)
(one (add one))
((one (add one)) 1)
(((one (add one)) 1) test)
((one (add one)) zero)
(((one (add one)) zero) 1)
(((one (add one)) zero) test)
((((one (add one)) zero) test) 1)
((((one (add one)) one) test) 1)
((((one (add one)) zero) test) 1)
((((two (add one)) zero) test) 1)
((((two (add one)) two) test) 1)
((((two (add twp)) two) test) 1)
((((two (add two)) two) test) 1)
((((two (add two)) one) test) 1)
((one add) two)
((((two add) two)) one)
test
(define zero (lambda (f) (lambda (x) x)))
(cons 2 3)
(cons (cons 1 (cons 2 3) 4))
(cons (cons 1 (cons 2 3)) (cons 4 nil))
(cons (cons 2 3) (cons 4 nil))
(cons 1 (cons 3 4))
(define h1 (lambda (x) (if (pair? x) append cons)))
(h1 (list 1 2))
((h1 (list 1 2)) (list 3 4) (list 5 6))
(define h1 (lambda (x) (if (pair? x) append)))
((h1 (list 1 2)) (list 3 4) (list 5 6))
(define h2 (lambda (a b) ((if (pair? a) append cons) a b)))
((h2 (list 1 2)) (list 3 4) (list 5 6))
(h2 (list 1 2))
((h2 1 (list 2)) (list 3 4) (list 5 6))
(append (list 1 2) 3)
accumulate
(quote (quote (quote a)))
(quote (quote (quote a)))
(quote a)
(eq? (list 1 2) (list 1 2))
(define a ((define b 1) (define c 2) this))
(define (a) (define b 1) (define c 2) this)
(define (a) (define b 1) (define c 2) this)
(eq? a a)
(pair? (array 1 2))
(eq? "a" "a")
(quote (quote (quote (quote a))))
(type +)
(type (lambda (x) x))
(if #t)
((if #t) "a" "b")
(if (#t) "a" "b")
(if (eq? #t #t) "a" "b")
(= #t #t)
accumulate
random
(caar)
(caar (list 1 2 3))
(caar (list (list 4 5 6) 2 3))
set
set-cadr
set-car
set-cadr
set-cadr!
set-car!
(setElement (list 1 2 3) 1 5)
(define a (list 1 2 3))
(setElement a 1 5)
a
(list nil nil nil)
(setElement (list nil nil nil) 1 1)
(cdr (list nil nil nil))
(quote (1 nil nil))
(define a (quote (1 nil nil)))
(car a)
(cadr a)
(caddr a)
(setElement a 2 (treeNode 2 nil nil))
(define (treeNode val left right) (list val left right))
(setElement a 2 (treeNode 2 nil nil))
a
(car a)
(cadr a)
(caddr a)
(caddr a)
(car (caddr a))
(caddrr (caddr a))
(caddr (caddr a))
(caddr a)
(caddr (caddr a))
(eq? (caddr (caddr a)) nil)
(setElement (caddr a) 2 (treeNode 3 nil nil))
a
a
(define a (treeNode 1 nil nil))
(setElement a 2 (treeNode 2 nil nil))
a
(length a)
(setElement a 2 (treeNode 3 nil nil))
a
(define a (treeNode 1 nil nil))
(treeNode (car a) (cadr a) (treeNode 2 nil nil))
(define a (treeNode 1 nil nil))
nil?
(append (list 1) (list 1) (list 1))
(define a )
(cons 1 a)
(cons 2 a)
(+ 1 (+ 2 nil))
map
(map + 1)
(map + (list 1 2 3))
(map + (list 1 2 3))
(map real (list 1 2 3))
(filter)
flatmap
